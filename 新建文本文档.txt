1绪论
1.1选题意义及应用背景
随着信息科学与微电子技术的发展，智能移动终端设备在人们生活中扮演起了越来越重要的角色[1]。对于智能手机而言，年轻人用它来娱乐，老年人用它来开阔视野，现在政府办公也有很多业务都依赖于智能手机。智能移动设备以其功能的多样性丰富着我们的生活，以其独有的便携性方便着我们的生活[2]。据《21世纪经济报道》报道：截止2016年7月，中国智能电话用户总数已经达到了13.04亿户。第三方数据统计机构国际数据公司也公布了2016年全球智能手机的销售数据。数据显示，2016年度全球智能手机销售量为14亿7060部。随着科技的发展，更多的丰富的智能移动终端设备将走进我们的生活。虽然智移动设备能耗小，但是数目多，总体的能耗可观[3]。随着电子信息技术的发展，智能移动设备拥有了比以往更高分辨率的显示屏、更快的CPU以及更大的存储器和更高的通信带宽。这些改变使得智能移动设备越来越智能，运行的应用程序也越来越丰富和复杂。但是这些硬件的改变和越来越来丰富的应用却使得智能移动设备的电能消耗越来越严重[4]。如果一台充满电的智能手机在正常使用的情况下，仅仅只能续航一天多的时间。
与PC个人电脑相比，智能移动设备的计算能力和电池储量都非常有限[5]，难以维持比较复杂的计算和庞大的通信。虽然随着半导体技术的发展，电池技术有了一定的提升，但是对于智能手机在续航问题上仍然还没有取得突破性的进展，因此续航时间的有限性极大的限制了移动应用的发展。为了获得丰富且有效的网络服务，智能移动设备的节能问题成为一个亟待解决的关键问题[6]。
根据摩尔定律，半导体技术在短时间内已经难以得到突破，人们开始把智能移动设备的节能问题由硬件的层面的考虑转向了使用软件的方式来解决[7]。随着虚拟化[8]技术和分布式技术的发展，云计算在ICT(InformationandCommunicationTechnology)领域迅速成长，如今的云计算服务商已经可以向用户提供一个高效、可靠的云计算服务平台[9]。利用云计算技术,人们可以通过网络获得强大的计算能力、存储能力以及基础设施[10]。
所以我们设想，如果把智能移动设备上的应用任务部署在云计算平台中高效执行的话，不仅可以提高移动应用程序的服务质量，而且可以有效地提高智能移动设备的续航能力，从而提高用户的体验。相关研究表明，这种方法完全可行，而且可以很好的改善智能移动设备的能耗情况[11,12]。在ICT领域把这种方法称为基于云计算的计算卸载。
本文针对现在主流的Android设备，着力设计和实现一种供Android应用开发人员使用，轻量级、易用、智能的计算卸载开发框架，在保证原应用程序服务质量的前提下，使应用程序具有云卸载功能，能将任务轻松部署在云计算平台运行，从而提高原应用程序服务质量以及减少移动设备的耗能。
1.2国内外研究现状分析
计算卸载这个名词出现在通信领域其由来已久，但是却一直没能成为科学研究的热点。直到云计算技术的蓬勃发展和移动应用的爆发式增长，科学家们才开始对它进行深入的研究，基于移动云计算的计算卸载技术作为移动云计算研究的一个分支，已经成为了当下的一个研究热点[13]。计算卸载技术主要是用于通信领域，目前来说国外比较有名的计算卸载项目有MAUI、CloneCloud以及ThinkAir。
1）MAUI，MAUI[14]是比较早的一个做计算卸载的项目，它为应用程序提供了一个特定的执行环境，可对应用程序进行方法级别的细粒度划分，要求开放人员对需要卸载方法进行标注，从而判别和抽取需要进行卸载的代码。它主要通过对比方法在本地执行消耗的能量和方法经过卸载计算消耗的能量来作出卸载决策。对于MAUI，它要求在移动设备和服务器云端都要建立一套自己的运行环境，操作较为复杂[15]，而且只支持Microsoft.NETCommonLanguageRuntime(CLR)下的应用。它的应用范围不广。仅仅只支持微软系列的WindowsPhone。
2）CloneCloud，CloneCloud[16]于2010年问世。它出现在MAUI之后，MAUI着重于被卸载方法的能量消耗，计算卸载力求达到能耗的最小化。而CloneCloud是专门为移动设备和云端的弹性计算设计的。对于需要卸载的部分，CloneCloud利用静态代码分析器来标注可编程字节代码中可能的迁移点，然后利用动态分析的方式来进行卸载决策。CloneCloud的数据传输量比较大，而且要求每个应用程序在云端都需要一个独立的虚拟机实例为它提供服务。相对来说比较消耗计算资源。
3）ThinkAir，ThinkAir[17]是继MAUI和CloneCloud之后出现的一个比较有名的计算卸载项目。它类似于MAUI，可以提供一个方法级别的颗粒度分割，同样需要开发人员对需要卸载的方法进行标注。但是它在云端服务器有作出了相应的扩展，如果检测到某个虚拟机资源耗尽的话，ThinkAir不会立刻就返回一个异常，它会调用别的虚拟机来继续进行计算任务。
对于国内的情况而言，还没有出现比较成型的计算卸载框架应用软件，大多数研究还是围绕在对计算卸载理论中资源的调度策略上。大多数的文章也都停留在对计算卸载框架的概念设计中。这对于想要运用计算卸载技术提高自己应用程序服务质量的应用程序开发人员来说，无非是一个巨大的损失。针对于已有计算卸载框架的不足和国内的这种情况，本文基于计算卸载的过程模型，以面向切面编程（AspectOrientedProgramming，AOP）作为关键技术结合现今火热的的移动云计算技术设计和实现了一款基于Android的计算卸载框架。

1.3论文的主要研究内容
本文受到MAUI的启发，与MAUI具有相似的目标，设计计算卸载框架的主要目的是为了提高应用程序的服务质量和降低移动设备的能源消耗。本文将结合Android应用程序的相关特点和开发人员的基本需求设计与实现一种供开发者使用，轻量级、智能化、应用于计算密集型应用的计算卸载框架。从而能让使用了计算卸载框架的应用程序轻松拥有云卸载的能力，在保证应用服务质量的前提下，提高智能移动设备的续航能力。本论文的主要研究工作如下：
1）对计算卸载理论进行相关研究，抽象出计算卸载的详细过程，建立计算卸载过程模型。针对计算卸载过程中任务卸载的决策问题，给出了基于任务代价预测的智能决策策略以及基于蚁群算法的智能决策策略用于计算卸载的智能决策。
2）通过分析计算卸载的过程模型，结合应用开发者的使用习惯，从中提取出计算卸载框架的基本功能需求，并为计算卸载框架建立功能模型、静态模型和行为模型，从不同角度分析框架，以便从整体上认识计算卸载框架。
3）深入分析计算卸载框架的各项功能需求，确立了计算卸载框架的总体架构。结合现今流行的编程思想与代码技术，对计算卸载框架进行详细的系统设计。在完成计算卸载框架所需的基本功能后，基于神经网络创建了计算卸载的预测模型，用以支持计算卸载框架的智能化卸载。
4）对于计算卸载过程中应用程序方法的状态转移过程，以最小化传输，最短时间消耗为目标，建立了饥饿传递、懒惰传递和甬道传递三种各具特色的数据传递方式。支持在不同条件下的状态转移需求。
5）利用现今比较先进的自动化测试工具对计算卸载框架进行了功能性的单元测试。分别使用了两种类型的Android应用程序分组测试了计算卸载框架的应用效果并对测试结果进行了详细的分析。
1.4论文的组织结构
本文针对智能移动设备的能耗问题，通过分析计算卸载的过程模型，给定了计算卸载框架的功能需求，并对功能需求进行细化描述，完成了基于Android的计算卸载框架的详细设计和代码实现，各章节主要内容如下：
第1章绪论
绪论主要介绍了本论文的应用背景以及计算卸载技术的国内外研究情况，针对国内计算卸载实现技术研究的短缺确定了本文的研究内容并说明本论文的主要工作和论文的组织结构。
第2章系统的相关理论及技术
主要介绍实现基于Android的计算卸载框架的相关理论及技术，包括计算卸载的理论建模以及显示意义，以及对神经网络、AOP技术、Java反射技术和BOINC网格计算平台的介绍。
第3章计算卸载的智能决策策略
对计算卸载的卸载过程进行研究，建立了计算卸载的过程模型，针对计算卸载过程中的卸载决策问题，给出了基于任务代价预测的智能决策策略以及基于蚁群算法的智能决策策略，用以支持计算卸载的智能决策。
第4章基于Android的计算卸载框架的分析
对基于Android的计算卸载框架进行需求分析，确定系统需要实现的基本功能，并从功能模型、静态模型和动态模型三个方面对计算框架的功能做出详细分析得出了计算卸载框架的分析模型。
第5章基于Android的计算卸载框架的设计
对基于Android的计算卸载框架进行概要设计和详细设计，包括对框架的总体体系结构设计以及对系统功能模块的划分，确定功能模块之间的关系，为每个模块的功能进行具体描述，设计功能模块的方法流程。
第6章基于Android的计算卸载框架的实现与测试
完成基于Android的计算卸载框架的实现和测试，介绍系统的开发环境，以功能模块为核心进行逐步开发，完成计算框架的各项功能，并对框架进行了相关单元测试和性能测试。
第7章结论与展望
总结全文，归纳工作成果，总结系统还存在的不足，并对基于Android的计算卸载框架提出改进以及做出展望。

2系统的相关理论及技术
本章主要介绍计算卸载的相关理论与技术，并对实现本文给出的基于Android的计算卸载框架的实现所需要的关键技术进行相关介绍，从而为后续章节提供相关的供理论和技术支撑。
2.1计算卸载
在计算机科学领域，计算卸载是一种将计算任务转移到另外一个平台进行执行运算，把最终计算结果返回原来机器的代码迁移技术[18]，这里的另外平台是指本机以外的设备，比如集群，网格计算单元或者是云。
这种技术的产生源于执行程序的设备本身硬件的约束，比如CPU计算能力的不足，运行内存过小以及存储空间的限制。当设备运行某高计算量的程序或者需要高内存的程序时，这些设备就很可能表现的很吃力或者根本运行不了这类程序。但是借助计算卸载技术就可以很好的解决这些问题。
另外，对于具有足够运算能力和相应运行内存设备，可能还存在着电量消耗巨大的问题，比如现在的智能移动设备。现在的智能移动设备在运算能力上相对以前的设备有了很大的提高，在电能存储方面也有了相应改善，但是对于高密度计算的程序而言，这些设备虽然能够支撑的起程序的运行，但是设备发热严重，耗电量巨大，对于设备的续航产生了非常不利的影响。结合了云的计算卸载技术对移动设备的节能减耗可以说是一个很有效的手段[19]。
2.2AOP技术
AOP是AspectOrientedProgramming的缩写，意为面向切面编程，它的主要目的是在业务处理过程中对切面(Aspect)进行提取，所关注的是处理过程中的某几个阶段或步骤，降低各业务逻辑之间的耦合度[20]。可以通过预编译方式和运行时动态代理，实现在不修改源代码的情况下统一给程序动态添加工程。上文提到的切面是从对象中抽取出来的横切性功能模块[21]。类似于面向对象编程(ObjectOrientedProgramming,OOP)中的一个类，由通知(Advice)和切入点(Pointcut)两部分组成。Advice是切面的具体实现，例如具体的日志操作代码，一般是切面中的某个方法。Pointcut会对应一个表达式，定义了Advice应该被插入到什么样的连接点(Joinpoint,JP)上，也可以理解为Advice的适用范围。Joinpoint则指的是目标对象中插入通知的地方，可以理解为通知的应用位置。对于理解AOP，我们还需要了解AOP中的目标对象(Target)、代理对象(Proxy)和织入(Weaving)这几个基本术语。目标对象指的是将会被AOP通知的对象，AOP将会通过通知切入这些对象来完成相关的业务逻辑，这些对象中一般只有核心的业务逻辑代码。而对于代理对象而言，它是目标对象收到通知之后被创立的，代理对象除了目标对象具有的相关业务功能外，还具有系统相关的公共功能。对于织入的理解，它指的是AOP通过目标对象创建代理对象的这个过程，这个过程可以发生在编译期也可以发生在代码运行期间。如果发生在运行期，则可以通过Java语言的反射机制和动态代理机制来动态实现。如图2-3所示，为AOP的工作示意图。用户需要进行新增用户、新增新闻和新增商品这几个业务时。都会被日志切面、权限切面和事务切面拦截。日志切面会在进行业务处理时进行操作的记录，权限切面会对请求业务的用户进行权限验证，若是权限不够，切面直接砍掉了该业务后面的流程，事务切面的工作方法也同上面两种类似。上一小结对计算卸载进行了相关介绍和建模，对于卸载过程中方法任务的拦截可以使用这种方式来实现。

图23AOP工作示意图
目前，AOP的实现很多。常见的有AOP框架有AspectJ、AspectWerkz、JBossAOP和SpringAOP，以及现在针对Android设备比较火的Aspectjx等。它们都是基于Java语言开发，可以很好的应用于Java应用程序的开发。
2.3神经网络
在机器学习[22]和认知科学领域，人工神经网络[23]（ArtificialNeuralNetwork，ANN），简称神经网络（NeuralNetwork，NN）或类神经网络，是一种模仿生物神经网络(动物的中枢神经系统，特别是大脑)的结构和功能的数学模型或计算模型，用于对函数进行估计或近似。神经网络由大量的人工神经元联结进行计算。大多数情况下人工神经网络能在外界信息的基础上改变内部结构，是一种自适应系统。它常常用来完成某种信号处理或者模式识别的功能、构建专家系统、制作机器人、复杂系统控制等等。目前常见的神经网络模型有：感知器神经网络、线性神经网络、BP神经网络、径向基神经网络、自组织神经网络、反馈网络等。感知神经网络按只有一个神经元，它通常使用线性阈值单元作为网络的传递函数，一般只能输出两个值，这样的神经网络比较适合解决简单的模式分类问题。线性神经网络是比较简单的一种神经网络，由一个或者多个线性神经元构成[24]。采用线性函数作为传递函数，所以输出可以是任意值。线性神经网络可以采用基于最小二乘LMS的Widrow－Hoff学习规则调节网络的权值和阈值，和感知器一样，线性神经网络只能处理反应输入输出样本向量空间的线性映射关系，也只能处理线性可分问题。BP神经网络通常指的是基于误差反向传播算法的多层前向神经网络[25]。BP神经网络一般采用Sigmoid型的可微函数作为神经元的传递函数，因此，我们可以利用BP神经网络实现输入和输出之间的任意非线性映射，这对于解决一些领域的非线性预测问题提供的有力的工具。
2.4Java反射机制与注解
Java反射机制[26]是指，在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。可以说只要知道运行程序中某个类的名字，通过java.lang.Class和java.lang.reflect包中的相关类就可以访问被反射的类的属性、方法和构造方法等。虽然说Java的反射破坏了Java的封装性，但是它还能够使我们的程序变的更加灵活。例如实例化一个person()对象，不使用反射，newperson()；如果想变成实例化其他类，那么必须修改源代码，并重新编译。使用反射：class.forName("person").newInstance()；而且这个类描述可以写到配置文件中，如**.xml,这样如果想实例化其他类，只要修改配置文件的"类描述"就可以了，不需要重新修改代码并编译。
Annontation是Java5开始引入的新特征。中文名称一般叫注解[27]。它提供了一种安全的类似注释的机制，用来将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联。更通俗的意思是为程序的元素（类、方法、成员变量）加上更直观更明了的说明，这些说明信息是与程序的业务逻辑无关，并且是供指定的工具或框架使用的。注解像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中。注解其实是一种接口。通过Java的反射机制相关的API可以用来访问注解信息。相关类（框架或工具中的类）根据这些信息来决定如何使用该程序元素或改变它们的行为。注解不会影响程序代码的执行，无论注解怎么变化，代码都始终如一地执行。Java语言解释器在工作时会忽略这些注解，因此在JVM中这些注解是“不起作用”的，只能通过配套的工具才能对这些注解类型的信息进行访问和处理。
注解一般作为一种辅助途径，应用在软件框架或工具中，在这些工具类中根据不同的注解注解信息采取不同的处理过程或改变相应程序元素（类、方法及成员变量等）的行为。例如：Junit、Struts、Spring等流行工具框架中均广泛使用了注解，使代码的灵活性大大提高。我们也可以使用自定义来丰富我们的应用程序。如图2-5所示，我们有一个注解的名字叫做NewAnnotation，它有一个String类型的参数value。可以用这个注解对类里的方法进行标注。被标注后的方法可以经过Java的反射机制被程序获得到，并能通过相关处理给涉及到的类或方法添加新的功能。

图24使用自定义注解范例
2.5BOINC计算平台
BOINC的英文全称为BerkeleyOpenInfrastructureforNetworkComputing，中文名称叫做伯克利开放式网格计算平台。它是一个用于志愿计算和网格计算的开放性中间件系统[28]。它被创建于2002年，并且为企业和个人提供了开源的的服务端和客户端代码供开发者开发使用。作为一个通用的计算平台，BOINC为用户提供了一套公用的计算组件，用户配置好平台的服务器和客户端后，通过平台提供的API就可以很简单的实现共享计算和志愿计算。BOINC会屏蔽掉一些系统的硬件特性，无论是Windows系统还是Linux系统或者是MacOSX系统，BOINC都能体现出它良好的计算能力，BOINC是一个跨平台的网格计算平台。用户可以使用一些闲置下来的电脑参与到公共项目的计算中来。
如图2-5所示为BOINC的工作过程示意图。BOINC主要有项目服务器和客户端个人电脑组成。服务器具有监控装了BOINC客户端的个人电脑的状态的能力。如果有客户端电脑出于空闲状态，这台客户端电脑将会被启动一个新的工作单元。工作单元启动后会从服务器下载所需的二进制执行文件以及计算需要的输入文件。当计算结束后，处理后的数据将会被封装在一个文件里被传回给服务器。之后，服务器将会把客户端的工作单元挂起，让它处于空闲状态。

图25BOINC工作过程
2.6本章小结
本章介绍了实现基于Android的计算卸载框架所运用的相关理论与技术。其中计算卸载的过程模型是设计计算卸载框架的基础，其中AOP技术、Java反射机制与Java的注解是实现自动化卸载的关键，神经网络则是做出智能决策策略的关键技术，BOINC平台则可以作为计算卸载中计算服务的扩展支持。

3计算卸载的智能决策策略
计算卸载过程中的任务的卸载需要有一个决策策略来决定任务是否真的需要卸载到云端执行，不恰当的方法卸载可能会导致移动设备的能耗加剧和应用程序的服务质量降低。对于此问题，本章将给出一种计算卸载的智能决策策略用于支持计算卸载框架的智能化卸载。
3.1问题分析
由上一章相关理论可知，对于计算卸载而言，它是一种将计算任务转移到第三方执行，并把最终结果返回给原来设备的过程。结合移动云计算技术，利用计算卸载的方法可以减少智能移动设备的能耗和提高应用程序的服务质量。但是，对于应用程序中的任务而言，并不是所有的任务都需要卸载到云端执行。虽然把应用程序的任务卸载后可以减少这个任务在移动设备上的运行能耗，但是任务卸载过程中的网络通信同样会造成移动设备的能量消耗，盲目的进行卸载可能会导致移动设备的能耗加剧。另外，对于不同的移动设备，不同的网络环境，同一个应用程序在能耗和时耗上可能会有截然不同的表现。
引入计算卸载是为了减少应用程序在智能移动设备上的运行能耗以及提高应用程序的服务质量。倘若由于计算卸载过程中的其他额外消耗造成了移动设备的能耗加剧或者应用程序的服务质量降低，计算卸载的意义也就不复存在了。对于计算卸载的过程，需要有一套决策策略用于鉴别应用程序中可卸载任务是否真的需要卸载到云端执行以达到在保证应用程序服务质量的前提下，使得移动设备能耗最小的目的。
3.1.1问题建模
1）任务模型，我们可以把一个移动应用程序表示为一组串行的任务序列，这里的每个任务可以是程序里的一个方法或者是一个模型[29]。如图3-1所示，假设一个移动应用有个任务,每个任务的工作量用表示，每个任务数据的输入输出分别是和。这里设定每一个任务数据的输入等于它前一个任务数据的输出。

图31任务模型
2）通道模型，数据在传输的过程中会受到很多因数的影响，但是为了便于建模，这里规定通信时只有两种状态，分别是“好”和“坏”，分别用和表示。而当时间为时，就会有一个影响因子叫做通道增益与之对应。对于和而言，分别用和表示[30]。那么通信通道的状态传递矩阵可以表示为：
		（3-1）
假设数据传输过程中能耗是一定的，那么数据的传输率完全取决于通道的状态。所以当时，；当时，。所以平均数据传输率期望为：
		（3-2）

3）执行模型
(1)移动端执行(MobileExecution，ME)，如果第个任务是在移动设备上执行的，则完成任务所需要的时间用表示，消耗的能量为，其中是执行任务的工作量，是移动设备的时钟频率，是移动设备执行任务时的能耗率，我们假设它是恒定的。
(2)云端执行(CloudExecution，CE)，如果第个任务是在云端执行的，用表示第个任务在云端执行需要的时间，，其中是云端执行单元的时钟频率，一般来说，云端计算单元的CPU运算能力会比移动设备快很多，满足。任务在云端执行时，移动设备处于空闲状态，所以此时的能量消耗为，其中是移动设备在空闲状态时的能耗率。
(3)传输数据(SendingInputData，SID)，当第个任务被卸载到云端执行的时候，需要先传送的数据到云端。假设现在的时间点为，那么我们可以使用公式表示传输数据需要的时间。那么传输过程中的能耗函数可以用表示，其中为数据传输过程中设备的能耗率。
(4)接收数据(ReceivingOutputData,ROD)，如果第个任务是在云端执行的，但是第个任务需要在移动设备上执行，那么移动设备在执行第个任务前需要先接收来自云端的数据，这里我们用表示任务由云端转向移动设备执行，移动设备接收数据所需要的时间。那么接收数据所消耗的能量为，其中是移动设备接收数据过程中的能耗率。
当然，对于上述的模型，本文约定了以下几个约束条件。第一，云端需要有移动设备中每个任务的执行副本，能保证同样的方法在云端能够正常运行，且在云端运行的效果要比在移动设备上效果好。第二，以上几种模型的设备能耗率应满足关系式，其中为移动设备空闲状态下的能耗，为移动设备接收数据时的能耗率，为移动设备发送数据时的能耗率，为移动设备执行任务的能耗率，通过实际数据的测量计算，一般情况下四种能耗率的大小关系都会满足以上的关系。第三，这一系列任务最后的执行结果必须返回给移动设备。
4）数学模型
如图3-2所示，这种串行任务在移动设备和云端交叉执行的过程可以用一个有向无环图来表示。如图3-2所示，图中添加了两个虚拟节点，分别是源节点和目的节点。节点表示第个任务在移动设备端执行，节点表示第个任务在云端执行。图中每条边的权值为代表着从前一个任务到下一个任务移动设备所消耗的能量。对于这个过程所消耗的时间用D来表示。
图32计算卸载过程模型
当应用程序要执行一个完整的功能，而且要求能耗最小，那么问题就可以转化为图的最短路径问题。具体点说，就是在中，找到一条从出发到达的最短路径，而且还要满足整个执行过程所消耗的时间不能超过我们设定的时间阈值。这个问题可以用以下公式来表示:
		（3-3）
s.t.
		（3-4）
这里的表示所有可能路径的集合。因为任务的执行除了在移动设备上执行就只能在云端执行，所以这里总共有种可能的路径。再加上时间的限制，这一个问题可以说是一个NP完全的问题。
3.1.2改进思路
对于求解带权值的有向无环图中两节点之间的最小路径问题，最经典的方法就是Dijkstra最短路径算法。对于Dijkstra算法，要求知道每一条边具体的权值，才能通过算法流程获取到两节点之间的最短路径。但是对于计算卸载过程中，任务节点之间的路径权值却是未知的，这里要求程序开发人员凭借经验给出两个连续任务切换过程中的能耗和时耗才能使用这种算法进行卸载的决策。这种做法不仅会加大应用程序开发人员的工作量，而且经验值毕竟不是准确值，在不同的设备和网络环境下，经验值往往与真实值偏差很大，仅通过这种方法来确定边的权值，往往不能得到比较理想的结果，无法体现出计算卸载的优势以及计算卸载的智能化。另外，对于本问题，需要考虑能耗和时耗的最优化求解。由于程序在执行过程中，任务间切换所造成的任务代价具有很强的实时性，后一次任务切换的任务代价直接受前一次任务的影响，若是使用Dijkstra进行求解的话，由于是全局性的保存了上一个节点的信息，很可能会在有解的情况下却计算得出无解的结果。为了解决这个问题，可以将原本求解有向无环图的最短路径问题转换为求解不完全二叉树的最短路径问题。本文给出了一种基于任务代价预测的智能决策策略方法，用于计算卸载过程中任务调度的智能决策。
3.2基于任务代价预测的智能决策策略
3.2.1任务代价的预测
任务代价主要是指本次任务执行的能量消耗和本次任务执行的时间消耗。对于这些任务代价而言，它们的大小与移动设备的配置信息以及当前网络状态息息相关。、的代价表达式可以分别用式3-5和式3-6表示。
		（3-5）
		（3-6）
式中，c为移动设备cpu频率，m为移动设备当前内存，b为当前网络的带宽，t为当前网络的时延，为传输数据量。
为了能对任务卸载做出比较合适的决策策略，需要获得比较准确的和的值。通常情况下，我们会使用经验值对其进行设定。但经验值往往不能准确的描述当前的状态，这样很容易做出错误的任务卸载决策。另外，对于cpu频率、设备内存以及网络类型与能耗以及时耗之间并不是存在完全的线性关系。通过线性回归的方式来确定和的值也不能取得一个很好的效果。本文采用机器学习的方式，对任务执行的历史记录进行学习，针对每个任务建立学习模型，经过训练后得到每个任务的预测模型，从而获取和的值。
本文采用BP神经网络对和的预测模型进行建模。如图3-3所示为和预测神经网络结构图。该神经网络输入层有5个输入节点，分别是移动设备的cpu频率c、移动设备当前内存m、当前网络带宽b、当前网络时延t以及传输的数据量。对于神经网络的输出层包含两个节点，分别是移动设备任务的能量消耗e和任务的时间消耗d。由于输入参数对于输出基本属于同一类型的映射关系，所以本神经网络只有一层隐含层。设节点i和节点j之间的权值为ωij，节点j的阈值为bj，每个节点的输出值为xj，则每个节点的输出值可以根据上一层所有节点的输出值以及当前节点与上一层节点的权值和当前节点的阈值还有激活函数来实现。具体计算方法如式3-7所示。
		（3-7）
		（3-8）
其中f为激活函数。


图3-3预测神经网络结构
我们期望最终的输出e和d能尽可能的逼近真值。这里用向量表示期望的输出，用向量表示输出层的输出。由此定义神经网络的全局误差为：
		（3-9）
设计算误差函数对输出层的各神经元的偏导数为,可利用输出层各神经元的和隐含层各神经元的输出来修正连接权值。可用式3-10表示：
		（3-10）
		（3-11）
3.2.2任务卸载的智能决策
利用上述的神经网络可以预测出每个任务的能耗、。在此基础上本文设计了基于任务代价的智能决策策略方法，其方法流程表3-1所示。
表31基于任务代价的智能决策策略流程
描述：基于任务代价的智能决策策略流程
输入：S，D；S节点的；任务节点组成的图
输出：任务初始节点到目的任务节点的调度策略
步骤1：
初始化，，并把初始节点加入到待选节点集合B
步骤2：
从B中选取最小的节点，通过神经网络对它到其邻接节点的e和d进行预测，并计算出它到达邻接节点的和，若邻接节点的，则将和以及上一个节点的标号与邻接节点绑定，把该节点从B中剔除并把邻接节点加入到B
表3-1（续）

步骤3：
判断B中是否存在了目标节点，若存在，则根据节点信息逆向重构路径；若不存在且B中节点均无邻接节点，则表示此路径无解；若不存在且B中节点还有邻接节点，则重复步骤2。
步骤4：
根据重构的路径，生成任务的调度策略，输出结果
本方法将图的路径搜索问题转化为不完全二叉树的搜索问题来做，通过已经训练好的神经网络从初始任务节点开始对所有任务节点间切换的任务代价进行迭代预测，并根据预测的结果进行最优化分割，最后得出满足需求的任务调度策略。这里的能耗最小是针对于整体的任务集合而言的，结果的输出形式类似于0101的布尔序列，0表示该任务不需要卸载，1表示该任务需要卸载。
3.3基于蚁群算法的智能决策策略
神经网络需要大量的数据进行学习，才能得到比较理想的效果。对于一个全新的系统而言，它没有任何相关数据，此时是无法建立神经网络的。针对还没有历史卸载数据或者历史卸载数据很少的情况，本文给出了基于蚁群算法的智能决策策略。
蚁群算法描述的是蚂蚁在寻找食物过程中发现路径的行为，它是一种用来在图中寻找优化路径的几率型算法。设为第i个任务节点k轮迭代时的信息素总值，其中包括在此任务节点不卸载的信息素以及卸载的信息素。初始时刻每个任务节点信息素值相等，。蚂蚁在第轮运动过程中需要根据任务节点信息素决定下一步要经过的节点，表示第k轮迭代过程中，蚂蚁在某个任务节点处选择卸载或不卸载路径的概率
其中N为任务节点的个数，，为创新因子。
	当蚂蚁第k次从初始节点S走到目标节点D的时候，需要对蚂蚁走过的路径所产生的能耗和时耗进行一次评价，评价函数用式3-13表示：
其中为实际能耗，为期望的能耗，实际的时耗，为期望的时耗。
根据对蚂蚁第k次寻路路径的评价，可以确定蚂蚁在第k次寻路过程中所有路径节点上洒下的信息素。其求解表达式如式3-14所示：
其中T为路径的评价函数，H为常量，m是蚂蚁路径经过的节点数。
而对于每个任务节点信息素的消逝率取决于整个寻路过程中信息素的增加值，如果蚂蚁经过了n轮循环，则对于某任务节点上的信息素可用式3-15表示。
任务节点的信息素的浓度会指引蚂蚁下一次寻路往评价更好的路径收敛，在这里，蚂蚁每次寻得的路径就是计算卸载过程中的卸载决策策略。这个策略一开始可能不会很好，但是随着寻路次数的增加，它会逐渐向理想的真值收敛，逐渐做出比较好的卸载策略决策。它可以用来解决上一节给出的基于任务代价预测的智能决策策略中神经网络的冷启动问题。其算法的具体步骤流程如表3-2所示。
表32基于蚁群算法的智能决策策略流程
描述：基于蚁群算法的智能决策策略流程
输入：S，D；任务节点组成的图
输出：任务初始节点S到目的任务节点D的调度策略
步骤1：
初始化每个节点的信息素
步骤2：
根据式3-7进行概率对任务节点的进行卸载选择，由所有的任务节点的卸载选择构成卸载决策策略，任务初始节点S到目的任务节点D的调度策略
步骤3：
根据式3-8对卸载决策策略进行评价，由式3-11计算出本次寻路的节点信息素增量
步骤4：
更新所有任务节点的信息素，返回步骤2
3.4计算卸载的智能决策策略
基于任务代价预测的智能决策策略对应用程序任务的卸载可以起到良好的决策效果，但是任务代价的预测取决于神经网络预测模型的好坏。对于一个新的系统而言，针对应用的任务的执行记录很少，在一个很小的数据集上建立的神经网络往往可信度很低，其预测效果很不好。为了解决神经网络的冷启动问题，本文给出了基于蚁群算法的智能决策策略。针对本文设计的计算卸载的智能决策策略工作流程框图如图3-4所示。应用程序启动的时候，需要判断任务代价预测的准确率是否已经达到最低标准σ。如果对于任务代价预测的准确率已经达到了标准σ，则使用之前训练好了的神经网络对任务进行任务代价的预测，然后根据这些任务的预测代价进行决策得出计算卸载中任务卸载的决策策略，即直接进行基于任务代价预测的决策策略。随后更新预测的准确率，等待下一次应用程序的启动。对于任务代价预测准确率还未达到σ的情况，会先使用基于蚁群算法的卸载决策进行计算卸载的策略决策。每次得出卸载策略后也会对任务代价预测的准确率进行更新，然后等待应用程序的下一次启动。但是当任务执行的历史数据量达到N后，会启动对每个任务的任务代价预测神经网络的训练，等待神经网络训练完成后，还需要对上次任务中的任务代价进行重新预测，检查训练后的神经网络的预测值与真值的差距，更新任务代价的预测准确率，最后等待应用程序的再次启动。

图3-4计算卸载的智能决策策略流程框图
3.5实验结果与分析
由于没有公开数据集进行测试，本文修改了第六章给出的中国象棋测试程序采集了200局游戏的测试数据。随机选取了其中180局的数据作为数据集进行仿真实验。每局象棋游戏包含30步象棋走位，每步象棋走位平均需要5个任务进行串行计算得出。针对于每一个单独的任务，测试集中包含了约5000组单个任务的测试数据。这些数据数据包含了单个任务节点分别在本地和云端执行的真实能耗和时耗，以及任务执行前，设备的CPU频率、可用内存大小、当前网络带宽和时延以及传输的数据量。
实验以测试时每个任务节点各方面的真实记录模拟程序执行过程中的能耗和时耗以及当时设备的状态。分别对180局棋的程序过程在不同的决策策略下进行了仿真。如图3-5所示，为仿真的结果曲线。红色虚线表示的是每局的最佳决策策略的平均能耗。最佳决策策略可用由数据集中任务节点分别在本地和云端执行的真实能耗和时耗求得。绿色虚线代表的是无智能卸载决策策略下，程序执行设备的平均能耗。无智能卸载决策策略是指，对于每个任务节点的卸载策略都基于某一判别多项式进行，即对于目前设备的情况，根据某一多项式运算的结果，直接判断该任务是否卸载执行，仿真中以设备当前网络的带宽和时延为主要判别尺度，对于满足式3-17的任务节点才进行卸载。
		（3-17）
对于蓝色的实线，表示的是在基于任务代价预测的决策策略下的平均能耗，这个策略是本章3.2节中给出的决策策略。对于黄色的实线代表的是加入了冷启动后的基于任务代价预测的决策策略下的平均能耗。这种策略也就是本章3.4节给出的计算卸载的智能决策策略。对于此策略，设置任务代价预测的准确率标准以及任务节点历史数据量，也就是说，在对任务代价预测的准确率小于0.4或任务节点历史数据量小于3000之前，不会启用基于任务代价预测的智能决策策略，而是采用本章3.3给出的基于一群算法的智能决策策略进行任务调度的决策。这个决策策略是作为基于任务代价预测决策策略的冷启动过程存在的。
图3-5计算卸载的智能决策策略仿真
从仿真的结果以看出，程序在没有使用智能决策策略的情况下，每局棋局平均能耗在700mAh左右，并且随着数据集数据的增加，能量消耗的值也不会改变，究其原因主要是因为每一局棋程序执行的任务都是一样的而且每一局的设备状态和决策策略也未曾改变。对于使用了没有加入冷启动的基于任务代价预测的决策策略的情况而言，当数据集比较少时，设备的耗能有时候甚至比没有智能决策策略下还多，这是由于神经网络在数据集比较少的情况下预测不准确导致的，但是随着数据集的增多，经智能决策策略下的能量消耗逐渐向最佳决策策略下的能耗收敛。对于加入了冷启动的基于任务代价预测的智能决策策略，在数据集比较少的时候，其收敛效果虽然不是特别理想，但是总体来说比没有加冷启动的决策策略要好。实验证明在训练数据集达到一定数目的情况下，计算卸载的智能决策策略能够有效的收敛于最佳的卸载策略，通过此卸载策略，可以使得计算卸载过程中能量的消耗趋于最小。
3.6本章小结
本章分别给出了基于任务代价预测的智能决策策略和基于蚁群算法的智能决策策略，它们相互补充构成了计算卸载的智能决策策略。仿真结果表明，本章给出的计算卸载的智能决策策略可以有效的减少计算卸载过程中任务执行的能耗。
4基于Android的计算卸载框架的分析
在设计一个软件系统之前，我们需要充分了解用户的具体需求，确定系统的输入是什么，输出是什么，最后能够达到什么样的效果。上一章我们对实现基于Android的计算卸载框架的相关理论及技术进行了简单介绍。下面我们将从用户的角度出发，对计算卸载框架进行全面的需求分析。
4.1基于Android的计算卸载框架的需求描述
4.1.1计算卸载框架的需求背景
在软件工程里，框架可以理解为是整个或者是部分系统的可重用设计，可以表现为一组抽象构件和构件实例之间交互的一种方法，另外，框架还可以被认为是可被应用开发者制定的应用骨架。这两种说法分别可以从框架的应用方面和框架的目的方面做出理解。
针对框架的使用对象而言，大多数是一些应用软件开人员。软件开发人员在开发软件的过程中可能会遇到很多重复性问题但是又不想重新编写同样或者类似的代码这些问题；另外，对于一些比较复杂的问题，他们没有能力或者没有足够的精力来自己解决，他们会寻求一种简单有效的方式――利用现成的软件框架解决问题。针对于计算卸载领域理论的研究，可能大部分应用软件开发人员都不会去涉及，他们的主要职责只是应用软件业务功能的开发，但是他们若想要使得自己的应用程序具有计算卸载的能力，这时他们就需要一个专门做计算卸载的软件框架的支持。对于应用软件开发人员而言，他们肯定希望被提供的软件框架使用起来越简单越好，如果框架的使用比自己编写一个相关功能的代码还复杂，估计也不会有多少应用开发人员想要使用这个框架了；他们当然也希望框架的执行效率越高越好，效率一直是所有行业都提及的重点，若是使用某框架去解决一个问题比不使用框架去解决这个问题效率还低，那使用框架也毫无意义了。
针对框架的应用对象而言，计算卸载框架主要应用于一些计算密集型的移动应用程序。因为对于计算资源比较紧缺，续航能力不是很强的移动设备而言，当他们运行一些计算密集型应用程序的时，它们会显得格外吃力，甚至是没有能力运行这类程序。这类计算密集型应用程序一般拥有一些纯粹的计算单元，它们一般很耗CPU或者很占用内存，所以当配置不是很高的移动设备在运行这些程序的时候常常都不会表现的太好，除此之外电池的消耗肯定也是不菲的。为了提高应用程序在移动设备上的运行效果，减少移动设备的电量消耗。我们可以借助云端丰富的计算资源，将一些复杂的计算通过互联网卸载到云端执行，然后将结果返回移动设备，最终达到程序的业务目的。
4.1.2基于Android的计算卸载框架的需求说明
通过上一小节对于计算卸载框架需求背景的描述，我们可以很容易就把计算卸载框架的使用对象和应用对象确定下来。首先，计算卸载框架的使用对象是进行移动应用软件开发的开发人员，其次，计算卸载框架的应用对象应该是那些开发后会被运行在计算资源紧缺的智能移动设备上的应用程序。开发人员可以在已有的应用程序里嵌入计算卸载框架，使得原来的应用程序具有计算卸载的能力，从而可以通过计算卸载的方式提升应用的服务质量以及提高移动设备的续航能力；或者开发人员在计算卸载框架的基础上来全新构建带有计算卸载能力的移动应用。这里的计算卸载框架应该具有简单易用、轻巧灵活和易于扩展的特点，当然还要有能够帮助移动应用程序轻松拥有计算卸载能力的功能。
上一章中本文介绍了计算卸载的相关理论，所谓的计算卸载，可以分割为计算和卸载两大部分。计算一般由计算资源比较丰富的第三方来实现，卸载描述的则是把需要卸载的方法转移到第三方的过程。那么很明显，对于计算卸载框架的功能需求而言，计算卸载需要具备一定的功能模块可以将需要卸载的方法转移到第三方去，另外，这里的第三方如何实现计算的整个过程也是计算卸载框架所需要关心的事。由此，本文将基于Android的计算卸载框架的需求分为移动端SDK需求和云端服务器需求两部分来进行描述，下面列出了它们的相关功能性需求的说明。
1）移动端SDK需求说明
简单而言，对于移动端SDK，它需要能够支持大多数的Android设备，并且需要一套能够自动识别应用程序中需要卸载的程序部分的方法，并且能够在传输出错或者其他异常情况下恢复原来方法的计算的能力。下面将对这些功能需求进行详细说明。
（1）支持Android应用程序
本设计是基于Android的，所以计算卸载框架首先要能够支持Android应用程序并且能够在主流的Android设备上运行。
（2）自动识别需要卸载的方法
移动端SDK需要能够自动识别出需要做计算卸载的方法(或函数)，这样应用软件开发者们在使用计算卸载框架的时候才能真正的减少工作量，同时也会使开发者能够更注重自己业务逻辑的开发，不用因为想增加一个卸载功能而大批量的修改源代码。
（3）状态的保持
对于计算的卸载，即使大多数的情况下都是可以成功的。但是也不能保证百分之百的计算卸载成功率。服务器宕机、网络的波动或者移动设备的小故障都可能导致计算卸载的失败。移动端SDK需要有一个状态保持机制能够使原应用程序在卸载失败的情况下尽可能的恢复原来的状态，从而不影响原来程序的正常运行。
（4）状态的转移
所谓计算的卸载，其实就是计算的转移，本来应该由自己来做的事情交给别人来做，再从别人那拿回结果。这种转移并不是单单的传递几个参数就能完事的。它不能是像Webservice[31]那样，已经由开发人员在服务器为特定的方法写好了特定的API，应用程序只要访问这些API就能从服务器获得对应的结果。这里要求将移动程序此时的状态传递到服务器，让服务器处于移动设备上应用程序一样的状态继续进行后续的操作。
（5）智能的卸载
虽然说利用云端丰富的计算资源进行卸载计算一般来说会都会比在移动设备上计算效率高。但是也不能一味的将方法卸载到云端计算，因为在状态传递的过程中可能会造成大量的流量消耗，对于处于3G或者4G等移动网络环境下的移动设备，大量的流量消耗可能会造成高额的流量费用[32]，这是应用程序的使用者所不希望的。再者，如果网络不稳定、网络波动大都很容易造成卸载的失败。卸载失败不仅造成流量上的消耗，还会增加原方法的执行时间，这样就会导致移动应用程序运行效果不佳。所以移动端SDK还应该具有智能卸载功能，能根据一些历史数据、设备配置、网络状态等做出一定卸载策略，控制方法的卸载。
（6）获取移动设备配置与状态
移动端SDK需要能够获取到移动设备的配置和移动设备实时的状态。在做智能卸载时，决策制定的依据首先应该是设备的配置。对于计算能力很强的智能移动设备，若要应用程序达到最好执行效果，其实不需要进行卸载，在本机运行可能比进行计算卸载的服务效果更好。另外，对于移动设备实时的状态。比如可用内存的大小，所处的网络环境也都是进行决策制定的关键因素。移动端SDK需要具有获得这些关键因素的能力，才能给智能卸载做出决策提供可靠的依据。
（7）具有记忆功能
具有记忆功能是指移动端SDK需要有一个数据库能够对卸载过的方法进行监测记录。历史数据往往也是做出决策的有效依据。移动端SDK需要在对方法卸载过程中对一些关键数据，比如某方法在某配置移动设备某网络环境下进行卸载所消耗的时间，所消耗的流量等进行记录，可以作为有效的依据提供给智能卸载的功能模块。
（8）良好的通信机制
作为计算卸载框架移动端SDK，需要具有网络通信功能才能与云端进行交互。当然，这不单单只是做网络通信而已，由于进行的是计算卸载的工作，为了提高通信的质量和速度，移动端SDK应该具备一套良好的通信机制，比如一些良好的数据传递机制，一些缓存机制等，尽量减少计算卸载时的流量消耗以及时间开销。
2）云端服务器需求说明
对于支持计算卸载的服务器，它应该是应用程序进行卸载后的实施主体。卸载后的方法实际上是在云端服务器上运行的。作为服务器它应该具有相应的一些功能用以服务移动端SDK，另外应该具备一些管理功能供开发人员的后期维护。下面将对云端服务器的功能性需求进行详细描述。
（1）接收状态和恢复计算
作为为移动端SDK做计算卸载支持的云端服务器，其最主要的功能就是为框架提供计算的服务。移动端SDK具有将本地状态转移到云端的能力，那么在云端的服务器当然要具有接收这些状态的并恢复计算的能力。
（2）计算的扩展
所谓的服务器不可以只是一台服务器，在做计算的时候，可以由一台服务器来完成，也应该可以由一个服务器集群来完成，这样的话可以让服务器可以支撑起其更海量的运算，对大量计算卸载任务的支持，希望可以具有计算扩展的能力。
（3）能给多个应用提供服务
若是每个需要进行计算卸载的移动应用程序都配套一个服务器为它们服务，这样也未免太浪费资源了。在云端配置的服务器应该可以同时为多个移动应用程序提供计算卸载服务，这样才能体现出服务器的存在意义。
（4）具有权限验证功能
由于要给多个应用程序提供计算卸载服务，如果没有一些权限的验证，则会导致计算卸载任务混乱，计算卸载工作不能顺利有效进行。
（5）能够管理应用程序
服务器若是能同时对多个移动应用程序提供计算卸载服务，那么服务器也必定需要具备管理这些应用的功能。这里的管理不是指远程操控移动设备上的应用程序，而是要将这些需要做计算卸载的应用的相关信息在服务器注册下来，只为在服务器注册了的移动应用做计算卸载服务。注意，这里的注册具有唯一性，相当于每一个应用程序就是一个来服务器寻求计算卸载服务的顾客。顾客需要服务，当然也要准守服务器的相关规则，为每个移动应用创建档案并对它们进行监管是很有必要的。
（6）实现一个共享的策略库
对于每个需要进行计算卸载的移动应用程序，虽然它们各自的卸载策略不一定相同，但是它们衡量策略的好坏的标准基本是一致的。在服务器能把各个应用程序在做计算卸载过程中的各项参数和运行环境等数据记录下来，通过相关分析为应用程序生成一个共享的策略库，可以为应用程序做卸载策略提供一些有效依据。
（7）保存卸载历史记录
这是一项日志性的工作，对移动应用程序做计算卸载过程中的相关数据进行记录和归类其目的有二。第一，开发者查看卸载的记录可以定位检查应用程序中的卸载错误。第二就是为卸载策略的制定提供依据。
（8）具有预测能力
对于移动端SDK的智能卸载，不能所有判断都由移动端SDK来完成，这样肯定会耗费移动端的很多资源，云端服务器具有海量的计算资源，可以利用现有的卸载数据和移动设备现有的状态对方法卸载造成的影响做出预测，可以给移动端SDK智能卸载提供支持。
4.2基于Android的计算卸载框架的分析模型
上一节描述了基于Android的计算卸载框架整体的功能性需求，接下来将综合面向对象的相关理论和技术对该框架建立分析模型，本小结将从功能模型，静态模型和动态模型三个维度入手，以完成对计算卸载框架的全面分析，为后面进行框架的设计与实现提供依据。
4.2.1基于Android的计算卸载框架的功能模型
如图4-1所示为计算卸载框架的关键用例图，计算卸载框架分为移动端SDK和服务器两个子系统。在移动端SDK部分，需要进行计算卸载的移动应用程序作为参与者，它的主要功能需求就是进行计算卸载，对于计算卸载这个需求而言，需要SDK的自动识别、智能分析、状态转移这三个子功能作为支持。对于服务器的部分，其参与者为移动端SDK以及应用开发人员。应用程序的计算是由移动端SDK转移到云端服务器完成的，移动端SDK其实是作为应用程序与服务器之间的桥梁存在。开发人员在服务器比较关键的用例是对应用程序进行注册和查询历史卸载记录以及使用服务器的管理系统。下面对这些关键用例进行相关介绍。

图41计算卸载框架关键用例图
1）方法卸载
移动端SDK在计算卸载框架中的功能在主要表现为卸载的功能，移动端SDK的主要工作是将应用程序需要卸载的方法（或者函数）转移到云端服务器，而具体的计算是由服务器来完成的。对于移动端SDK的主要职责而言，它相当于是一个搬运工的角色。但是它又不是一个存储的搬运工，它还具有一定的智能分析能力。所以在进行卸载之前需要对设备和数据进行一定分析才进行卸载。如表4-1所示为方法卸载的用例描述。
表41方法卸载用例描述
用例	说明	
用例名称	方法卸载	
优先级	高	
来源	需求	
主要参与者	应用程序	
描述	该用例描述移动端SDK进行方法卸载的过程
前置条件	移动端SDK初始化完成
典型事件过程	参与者动作	系统响应
	第1步：应用程序执行可卸载方法时	第2步：自动识别出该方法，保存该方法的状态，并阻止该方法继续执行
		第3步：获取移动设备的配置信息以及实时网络信息
第4步：将相关信息上传到服务器，由服务器预测卸载影响并得出卸载决策
		第5步：移动端SDK根据决策对方法进行状态转移
后置条件	服务器可以使用卸载的方法进行计算
结论	当被卸载方法的相关信息被转移到服务器，用例结束。
2）权限验证
由于服务器不止只为一个应用程序提供计算服务，对于接入服务器的应用程序它们在服务器应该要具有自己特定的标识。服务器可以用这些标识来对区分对应用程序的计算服务，同时服务器需要生产一些凭证信息发放给应用程序，服务器只给具有凭证资格的应用程序提供计算服务。另外，开发人员进入后台管理系统也应经过授权才能够进入并进行相关操作。如表4-2所示为权限验证的用例描述。
表42权限验证用例描述
用例	说明	
用例名称	权限验证	
优先级	高	
来源	需求	
主要参与者	移动端SDK、开发人员	
描述	该用例描述应用程序和开发人员使用系统时的验证授权过程
前置条件	能够正确访问授权接口
典型事件过程	参与者动作	系统响应
	第1步：移动端SDK申	第2步：服务器通过识别相应的识别码进行验
表42（续）
用例	说明	
	请授权访问	证，验证通过返回授权码
	第3步：开发人员直接输入后台管理系统地址	第4步：服务器拦截用户请求并跳转至登录界面
	第5步：开发人员使用管理员账号登录	第6步：服务器进行验证，验证通过则跳转至管理系统主页
后置条件	移动端SDK可以使用授权码进行方法卸载，开发人员可以操作后台系统
结论	移动端SDK获得授权码或开发人员正常登录后台系统，用例结束。

3）智能决策
远程预测是对移动端SDK智能分析功能的服务器支持。当移动端SDK进行智能分析时会以本地策略以及远程智能决策为依据，给智能分析提供一定的判断条件，决定移动端的方法是否需要卸载到云端进行计算。如表4-3所示为智能决策的用例描述。
表43智能决策用例描述
用例	说明	
用例名称	智能决策	
优先级	高	
来源	需求	
主要参与者	移动端SDK	
描述	该用例描述移动端SDK请求智能决策的过程
前置条件	应用程序启动
典型事件过程	参与者动作	系统响应
	第1步：移动端SDK获取设备配置以及网络状态等信息	
	第2步：移动端SDK将设备配置以及网络状态等信息上传至服务器请求智能决策	第3步：服务器根据设备配置以及网络状态还有历史数据进行预测，得出当前状态下卸载方法会造成的影响，并返回决策策略信息给移动端SDK

	第4步：移动端SDK根据预测以及既定策略进行方法卸载	
后置条件	移动端SDK可以获得进行方法卸载判断的依据
结论	移动端SDK做出智能卸载判断用例结束。

4）计算服务
如果把计算卸载框架的功能一经划分，很明显服务器的主要工作就是“计算卸载”中的计算服务。移动端SDK将移动端应用程序的状态转移到服务器后，服务器需要解析状态并恢复该方法或者函数的执行，等得出最终结果后把结果返回给移动端SDK。计算服务应该是高性能、高稳定性的，应该能给承担的起较大的计算负荷。如表4-4所示为计算服务的详细用例描述。
表44计算服务用例描述
用例	说明	
用例名称	计算服务	
优先级	高	
来源	需求	
主要参与者	移动端SDK	
描述	该用例描述了移动端SDK请求计算服务的过程
前置条件	移动端SDK将方法状态转移到服务器后
典型事件过程	参与者动作	系统响应
	第1步：移动端SDK将方法状态转移到服务器	第2步：服务器对状态转移中的授权码进行权限验证
		第3步：对于拥有有效的权限码的计算请求，服务器将恢复被卸载方法的状态并进行计算
第4步：将计算结果及改变后的方法状态返回移动端
	第5步：移动端SDK根据返回结果恢复方法执行	
后置条件	移动端SDK恢复被卸载方法的执行
结论	应用程序被卸载的方法恢复执行用例结束。

5）应用注册
应用的注册应该发生在应用程序上线之前，服务器进行权限验证的相关信息需要在应用注册的时候生成。服务器需要对注册的应用生成一个唯一标识用来制定特定的应用程序。应用程序开发人员也应该在应用注册的时候完善好需要进行卸载的应用程序的基本信息，以及提供进行计算卸载的其他文件。如表4-5所示为应用注册的详细用例描述。
表45应用注册用例描述
用例	说明	
用例名称	用例注册	
优先级	高	
来源	需求	
主要参与者	开发人员	
描述	该用例描述了开发人员注册应用的过程
前置条件	开发人员已经登录后台系统
表45（续）
用例	说明	
典型事件过程	参与者动作	系统响应
	第1步：开发人员点击添加应用按钮	第2步：服务器展示应用注册基本信息页面
	第3步：开发人员上传应用注册需要的文件以及填写基本信息	第4步：服务器保存文件和基本信息并生产其他相关信息

第5步：服务器展示应用注册成功的页面
后置条件	注册后的应用可享有计算卸载服务的权限
结论	应用信息正常保存后用例结束。

6）记录查询
当开发人员想要对某个应用的历史卸载记录进行相关的研究的时候，需要先获得它们的历史卸载记录，计算卸载框架提供了保存历史卸载记录的功能。开发人员可以通过后台系统很轻松的获得这一部分数据。在后台对历史卸载记录的查询时，会按不同应用和不同时间段来查询。如表4-6所示为记录查询的详细用例描述。
表46记录查询用例描述
用例	说明	
用例名称	记录查询	
优先级	高	
来源	需求	
主要参与者	开发人员	
描述	该用例描述了开发人员对历史卸载记录查询的过程
前置条件	开发人员已经登录后台系统
典型事件过程	参与者动作	系统响应
	第1步：开发人员点击记录管理按钮	第2步：服务器展示应用历史卸载记录列表信息页面
	第3步：开发人员选择相应的筛选条件	第4步：服务器根据筛选条件展示相应的历史卸载记录
后置条件	开发人员能根据条件查看相应卸载记录
结论	服务器正常显示筛选后的卸载记录后用例结束。

7）管理系统
当开发人员登录后台系统后，会对系统进行相关的操作，其中包括对其它管理员账户的授权，对应用程序的管理，对历史卸载记录的管理，还有就是对系统一些基本配置的修改等。管理系统是后台系统的一个非常重要的子系统。
4.2.2基于Android的计算卸载框架的静态模型
前面的两节部分，我们对计算卸载框架的相关功能性需求进行了介绍，然后又对相关的关键用例进行了描述。通过这些基本需求和关键用例模型，我们可以抽象化得出计算卸载框架的核心类图，如图4-2所示。

图42计算卸载框架的核心类图
如图4-2所示为计算卸载框架的核心类图。在移动设备端，移动端SDK类为移动端SDK的入口类，移动应用程序可以通过这个类与移动端SDK进行交互。应具备初始化移动端SDK以及管理移动端SDK的其他组件的功能。对于权限验证的功能需求，移动端SDK可以通过验证器类与服务器进行交互从而进行移动应用程序的权限验证。对于智能分析部分，分析器类可以用于移动端SDK对移动设备的配置和网络状态的分析，同时分析器还可以与服务器交互获得预测结果。客户端代理是移动端SDK最重要的类，客户端代理控制着对应用程序相关方法进行卸载的主要逻辑，应用程序的状态转移也是由它控制的。通信代理类是客户端代理用做状态转移的具体实现类，另外自定义的状态类承载方法堆状态的信息，用于传输状态。
对于服务器端，服务器代理类具有状态恢复于计算分发的功能，可专门用来处理移动端SDK的卸载请求。对于计算执行器，它是代码卸载到服务器后的实际执行者，通信代理具有类似移动端SDK通信代理的功能，是服务器专门用来做通信的实现类，结果封装类承载了服务器对卸载后的方法进行计算执行后的最终结果以及改变的状态堆，通过通信代理返回给移动端SDK。应用管理类则主要用于服务器上应用程序的管理，预测器用于服务器智能预测卸载结果的请求，对应于开发人员管理共享策略库和制定特殊应用程序卸载策略的需求。记录管理类用于各个应用程序计算卸载历史记录的管理，卸载记录类为计算卸载历史记录的实体类,包含了卸载记录相关信息。
4.2.3基于Android的计算卸载框架的行为模型
静态模型展示了待开发系统的结构特征，而行为模型可以用来描述系统的过程和行为，常常用活动图来表示。下面我们将对计算卸载框架的四个典型行为进行分析，得出他们的行为模型。
1）初始化SDK
如图4-3所示为SDK初始化的活动图。应用程序调用SDK初始化接口后，移动端SDK开始初始化工作。初始化包括远程权限验证和初始化SDK组件两大部分。远程权限验证如果没有通过，则会直接导致移动端SDK初始化失败，如果验证成功，服务器会给移动端SDK发送一个授权码。移动端SDK收到授权码后将它保存在本地以供做方法卸载时使用。接着移动端SDK开始逐个初始化SDK的一些必备组件。凡是有组件没有初始化成功都会导致移动端SDK初始化失败。

图43初始化SDK活动图
2）计算卸载
计算卸载是计算卸载框架所要能实现的最主要功能。计算卸载的过程描述如图4-4所示。当移动应用程序要执行可卸载的方法或者函数的时候，移动端SDK需要拦截保持方法现在的状态，接着通过智能分析做出决策，决定这个方法或者函数是否需要卸载到服务器进行计算。若是决策认为该方法或者函数不需要卸载，则直接恢复原方法状态，程序继续往下执行；如是决策认为需要进行卸载，则执行状态转移，将方法或者函数执行涉及的堆转移到服务器。若是状态转移成功，服务器会根据相关方法在服务器恢复方法或者函数的执行，当方法或者函数在服务器执行完成后，服务器将此次计算卸载的信息记录下来，然后返回计算结果给移动端SDK，移动端SDK解析结果若是成功，则将原方法和函数涉及的堆的相应对象进行状态恢复，这样程序就可以继续往下执行了。

图44计算卸载活动图
3）应用管理
对于一个能支持多应用计算卸载服务的服务器，当然也需要支持管理这些应用的能力。开发人员登录后台系统后，可以进入应用管理页面进行创建新应用、修改原应用的信息和删除应用的操作。如图4-5为应用管理的活动图，描述了开发人员在应用管理的活动图。

图45应用管理活动图
4）记录查询
卸载记录的查询也会是应用开发者在后台管理系统的一个常见行为。应用开发者在后台管理系统可以根据各种条件对相关应用的卸载记录进行查询，以及排序。其活动图如图4-6所示。

图46卸载记录查询活动图
4.3本章小结
本章对应于基于Android的计算卸载框架系统需求的开发阶段，通过了解计算卸载框架的背景和目标，获得了计算卸载框架最初的原始需求。通过UML中的功能模型、静态模型和行为模型对这些原始需求进行分析，整理和归纳了计算卸载框架的几个关键用例以及相关行为的活动图，为下一章的系统设计提供了有力的依据。







6基于Android的计算卸载框架的实现与测试
本章将在上一章的基础上，给出基于Android的计算卸载框架的具体实现，介绍该框架的开发环境，解释各模块的关键代码，然后对框架进行测试，分析测试结果后并展示相关运行页面。
6.1系统开发环境简介
本文计算卸载框架主要分为移动端SDK和云端服务器两大部分。由于是面向Android应用程序的开发框架，我们将把移动端SDK作为AndroidLibrary进行开发，介于需要支持现在主流的Android设备，我们使用的AndroidSDK版本为API19。对于服务器部分，由于Android程序也是基于Java实现，而且还需要具备一些友好的开发人员管理页面，所以我们选用SpringMVC作为请求处理的前端服务器Web框架，对于网格计算部分选用的BOINC的网格计算平台。对于系统开发的具体环境如表6-1所示。
表61基于Android的计算卸载框架开发环境
考察方面	系统/软件/语言/框架
操作系统	OSXEICaption（10.11.2）
移动端SDK开发工具	AndroidStudio（2.2.3）、
移动端SDK的AndroidSDK	Android4.4（API19）
服务器开发语言	Java（1.8.0）
服务器开发工具	SpringToolSuite（3.8.2）
服务器Web容器	Tomcat（8.5.11）
服务器数据库	Mysql（5.7.17）
网格计算平台	BOINC（Debian）
虚拟化工具	VirtrualBox（5.0.24）
6.2基于Android的计算卸载框架的实现
对于一个应用程序的计算卸载需求，需要计算卸载框架的移动端SDK和服务器协调工作才能很好的完成。移动端SDK主攻卸载服务，服务器主攻计算服务，移动互联网是它们进行信息交互的纽带。前面章节已经对框架的设计有了一个详细的介绍，下面将对其中比较关键功能模块给出详细的系统实现。
6.2.1应用服务模块的实现
应用服务模块分为SDK初始化和SDK相关组件的初始化两大部分功能。这些功能的实际实施主体是在一个Service里进行的，这个Service是一个自定义的AndroidService服务，它由SDK初始化的时候启动，伴随着整个应用程序的生命周期。SDK初始化的过程在上一章相关小结已经有过相关所介绍。开发者需要在开发的时候在AndroidManifest.xml上的application标签里添加好APP_TOKEN的meta元素：
<meta-data
android:name="com.xjtu.meshine.mcloudsdk.APP_TOKEN"
android:value="979d472a84804b9f647bc185a877a8b5"/>
然后通过下面程序可以获得这个meta的数据值：
//在application应用<meta-data>元素。
ApplicationInfoappInfo=this.getPackageManager()
.getApplicationInfo(getPackageName(),PackageManager.GET_META_DATA);
appInfo.metaData.getString("com.xjtu.meshine.mcloudsdk.APP_TOKEN");
获得APP_TOKEN的值后，SDK将数据提交到服务器进行验证，这里的验证使用普通的HTTP请求即可，若是权限验证通过，服务器会返回给SDK一个accessKey，SDK获得accessKey后需要把它保存在本地内存以供后面的其他操作使用。对于SDK的相关组件，主要包括用于做验证的Validator、用于做分析的Profiler还有用来做卸载的ClientProxy和用来做网络通信的ClientNetManager对于这些类的实例都被设计为单例的，即SDK中只会有一个它们的实例。这都是出于系统资源以及相应速度的考虑，同样对于对象的控制也会更加安全。
6.2.2卸载服务模块的实现
1）自动识别的实现
移动端SDK对应用程序实现计算卸载的功能，并不是应用程序主动发起的，而是通过SDK自动识别的。根据AOP的思想，我们可以给每一个可以作为卸载单元的方法创立了一个切面，在切面中为原来的方法做状态的转移，经过服务器的协同工作，最后完成计算卸载。在这里，我们使用AspectJx这个支持Android程序的开源AOP编程开发框架。首先我们需要创建一个可以用来标注可卸载方法的注解，其详细代码如下：
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public@interfaceRemotableMethod{
StringalternativeClassName();//云端替代方法所在的类
StringalternativeMethodName();//云端替代方法的方法名
}
这个注解的名字叫做@RemotableMethod，通过@Retention和@Target的参数说明，把这个注解定位为是在运行期间对方法的描述。对于RemotableMethod注解，它具有两个String类型的参数其中alternativeClassName表示云端替代方法所在的类的全路径类名，alternativeMethodName()表示云端替代方法的方法名。这两个参数主要是在云端做代码替代时使用，在后续章节会对其进行相关介绍。这里的@RemotableMethod就是进入我们定义好的切面的切点，当被@RemotableMethod注解标注的方法被调用时，会被AspectJx监测到，然后根据配置转入指定的切面。切面的主要配置入下：

这里的切面是我们自定义的一个类，用来根据某种规则统一处理一些业务逻辑。这里对切面的配置也是采用注解的方式进行的。@Aspsect、@PointCut和@Around都是AspectJx自带的注解，@Aspect标注在OffloadingAspect类上面表明这个类就是用来横切业务的切面，具体哪些业务会被这个切面切断则由@PointCut标明，@Point的参数值为“execution(@RemotableMehtod**(..))”表明ApsectJx将会监测所有被@RemotableMethod标注的方法，一旦这类方法在程序中被调用就会被切面截断，先执行切面指向的片段后原来的业务才能恢复执行。这里指向的代码就是被@Around标注的offloadExecute(ProceedingJoinPoinpjp)方法。
2）智能分析的实现
对于被标定的方法不一定要被卸载到云端执行，若是当前需要卸载的方法做状态转移的数据量特别大那我们更加趋向于在移动上执行这个方法，若是方法需求的计算资源特别多，那我们可能更倾向于把方法卸载到云端去运行。总之，对于方法是否要卸载到云端服务器都需要一个决策分析，以某一方面最优的尺度来卸载方法。在进行分析之前我们需要获得移动设备的相关配置信息，对于Android设备其具体的配置信息与获取途径如表6-2所示。meminfo、version、cpuinfo这几个文件都存在系统文件夹
表62配置信息与获取途径
配置信息	获取途径	配置信息	获取途径
总内存	/proc/meminfo文件	系统版本信息	/proc/version
可用内存	ActivityManager	网络类型	ConnectivityManager
电量信息	/power_profile.xml	网络带宽	TelephonyManager
CPU信息	/proc/cpuinfo文件	厂商信息	android.os.Build

/proc内，对于总内存、CPU信息和系统版本信息的获取，是通过读取这些文件的相关行获得的，实现过程可以通过使用FileReader读取文件流的方式获得。对于可用内存、电池电量、网络类型这些信息需要通过系统服务获得，值得注意的是，想要获得Android设备的这些相关信息，需要在AndroidManifest.xml中添加以下的权限：

获取了设备当前的配置信息和网络环境后，我们首先要通过本地策略系统对当前内存和网络等信息做个初步决策，如果网络环境很差但是设备目前可以支撑的起应用的运行的话，那就会直接决定方法不再做卸载，如果是网络环境很好，会优先进行卸载，另外这里还好根据情况把相关信息上传到服务器由服务器来通过历史卸载信息以及策略共享库得出最后策略，具体的算法过程见第五章自动识别小节。对于神经网络的模型训练，本文使用Spring提供的定时器在每天固定的时候对不同应用的卸载记录进行训练。
3）状态转移的实现
对于状态的转移部分，我们首先要获取被卸载的方法的状态堆，简单来说也就是该方法涉及到的所有对象。为了能够达到这个目的，我们需要先人工对相关的类实现java.io.Serializeble接口。对于实现了这个接口的类，在进行网络传输的时候，Java的原生序列化方法会将对应的类的实例以及类里相关的类的实例序列化成字节码进行网络传输，字节码的接收端再通过Java的反序列化可以恢复这些类的实例。
状态的转移是在OffloadingAspect这个切面内进行的，当进入被@RemotableMethod标注的方法的切点时，AOP框架会根据配置转向执行对应的Advice。这里将会执行上文提到的切面里的offloadExecute(ProceedingJoinPoinpjp)方法。切面里的Advice可以被传入一个ProceedingJoinPoint对象，它包含了这个切点的详细信息，通过它我们可以获得被执行方法目前的状态堆，具体代码如下：
将带@EnableProxy的对象本地缓存后，我们将这些信息用自定义的Pack类封装后使用Socket与服务器进行通信，云端收到传送过来的信息后，会对这些信息进行反序列化，接着会遍历方法参数的所有类型，找到被对象代理替代的对象，然后通过ServerNetManager获取计算时真正需要的对象，最后由MethodExcutor交于计算单元进行计算得出最后结果，其关键代码如下：
值得注意的是，从对象代理获取真正用于计算的对象的时候，我们还建立了相应的缓存机制。带有@EnableProxy注解的类的实例被传送到服务器的时候，服务器会将这个实例的guid以及实例的二进制流存入本地数据库，于此之前移动端SDK在给服务器传输这个对象之前也会将它的guid和实例的二进制流存储在SDK的本地数据库。若卸载的时候该对象的MD5与数据库存储的二进制流的MD5相同的话，ClientNetManager会将该对象的@EnableProxy的isInCache参数的值设为true，然后将该对象的guidc保存代替这个类的对象代理上，之后在服务器上若是通过对象代理获取对象的时候，如果检测到该对象注解的isInCache为true的话，对象代理就会直接通过guid从服务器的缓存中获取需要的对象。
6.2.3权限服务模块的实现
权限服务模块属于服务器上的一个功能模块，它主要用来给应用程序进行权限验证的。当应用程序在初始化移动端SDK的时候，会将应用程序的APP_TOKEN上传到服务器，权限服务模块就会将APP_TOKEN与数据库里注册了的应用进行匹配，若是已经注册了而且是置于在线的应用。权限服务模块才会为该设备的这个应用生成相应的accessKey。accessKey是通过APP_TOKEN和到期时间通过MD5的加密方式生成的，每个生成的accessKey会被加入到一张在线的accessTable中。这张accessTable是专门用来记录，除了含有accessKey的信息，还会记录每个accessKey的到期时间，服务器对于应用程序的服务请求，都会先验证accessKey的有效性，accessKey还处在有效期内才会给移动设备提供服务。对于已经过期的acceKey，服务器会返回相应的信息通知移动端SDK重新申请accessKey。服务器也会定期清理accessTable中过期的accessKey，以方便数据的处理。对于获取acccessKey的过程的详细代码如下所示：
//通过TOKEN查询应用
当然谦虚服务模块的功能不仅仅只限于对移动端SDK的权限验证，它还负责服务器的后台管理系统的权限管理。服务器的后台管理系统是供应用开发者使用的，对于应用开发者如果想要在服务器注册相应的应用，他们必须通过后台管理系统来实现。在使用各个功能之前必须先登录平台才能够进行。对于后台管理系统的用户，我们系统初始化的时候默认只有一个超级管理员用户。超级管理使用初始密码登录系统，可以在系统内创建其他的管理员用户。权限管理模块通过Spring的拦截器来实现对管理员的权限控制。对于我们的后台管理系统来说，根路径下的所有url都需要进行权限的拦截，若是管理员没有登录，系统将重定向到登录页面提醒管理员登录相关代码如下所示：
6.2.4计算服务模块的实现
计算服务模块是程序卸载到服务器后，在服务器端真正执行计算的模块。对于如何在转移后的状态里寻找所要执行的方法，我们是通过Java的反射机制实现的，相关代码如下：
对于方法的执行，在第五章详细设计部分，我们还介绍到服务器具有替换原方法执行的功能，旨在满足应用开发人员对某些功能实现移动设备和服务器两种具体执行过程的需求。实现这种机制是通过对方法注解的参数判别完成的。在第五章代码替代的详细设计小结中，中本文介绍了@RemotableMethod注解的主要参数集，对于其中含两个主要参数，一个是alternativeClassName，一个是alternativeMethodName，分别表示替换方法所在的类以及替换方法的名字。我们在服务器接收完数据后，对需要调用的方法进行判别，若是配置了替换代码的方法，则将原方法替换掉再执行具体的计算，相关代码如下所示：
由于服务器是面向多应用服务的，这里会面临一个服务排号问题。对应本设计，由于还没有设计出良好的并发机制，所以我们暂时使用一个执行队列来控制服务器给应用的计算服务的服务顺序。对于处在执行队列里的任务，我们会按先进先出的顺序来执行。对于本设计，我们还提供了网格计算的支持。若是服务器开启了网格计算服务，这里的网格计算服务是结合第二章中介绍的BOINC网格计算平台实现的。对于需要执行的任务，我们将其转化为单个Java的可执行程序，然后经由Jsmooth转换接入BOINC的服务器进行运算。要值得注意的是，我们需要现在自己的云平台或者服务器部署好BOINC的服务器和客户端，并且需要使它们之间的通信带宽竟可能的大，关键代码如下：
6.2.5管理维护模块的实现
管理维护模块主要工作是应用的管理、历史卸载记录的管理以及管理员账户管理。这些模块都是基于SpringMVC开发的。我们定义了三个Controller分别用来主管这几个功能。它们分别是AppController，RecorderController，AdminController。对于每个Controller中的Action都会配置一个对应的url用来响应网页的请求。它们的实现方式比较相似，对于应用注册部分的业务服务层代码如下：
6.3基于Android的计算卸载框架的测试
软件测试是软件开发过程中一个重要组成部分，也是软件生命周期中一个不可缺少的阶段，软件测试对软件的稳定性的保障以及功能性的检验都至关重要。下面我们将对基于Android的计算卸载框架进行功能性和分析。
6.3.1系统的测试环境及说明
基于Android的计算卸载框架的测试环境如表6-3所示。服务器部署在MacOS系统上，单元测试采用的是JUnit4测试工具，对于Android设备的交互测试采用的是Uiautomator测试工具。
表63基于Android的计算卸载框架的测试环境
项目	硬件/软件
服务器部署	OSXEICapitan（3.2GHzIntelCorei5，8G）
单元测试工具	JUnit4
交互测试工具	Uiautomator2.0
动态DNS	花生壳3
硬件设备	多台Android手机
公网网络带宽	1M/s
内网网络带宽	10M/s
考虑到不同环境的测试，将手机设备置于不同的网络环境下进行测试。如图6-1所示，手机A和手机E处于内网环境使用Wifi进行通信，手机B、手机C和手机D处于公网环境下，通过移动网络进行通信。由于实验室没有公网IP做实验支持，这里利用花生壳的动态DNS技术做内网穿透，实现内网服务器的公网访问。
图61系统测试网络结构图
6.3.2系统的测试过程与结果分析
系统测试目标首先是要验证系统中各个功能的正确性，然后再测试各方面的性能，在保证系统功能没有错误的情况下再来提高系统的性能指标，测试的过程主要包括功能测试和性能测试两大方面。
1）功能测试
功能测试主要是为了确定系统提供的各个功能是否达到了既定的功能标准，各个功能模块是否能够正确执行，以检查是否满足需求分析中所要求实现的功能。这里我们使用JUnit4作为移动设备单元测试工具对移动端SDK的相关功能进行单元测试，使用Chrome浏览器对服务器管理后台进行相关功能测试，如表6-4所示为基于Android的计算卸载框架的测试用例及测试结果。
表64基于Android的计算卸载框架的测试用例及测试结果
功能模块	输入数据	期望结果	实际结果	测试结论
应用服务模块	分别使用正确和错误的APP_TOKEN向服务器申请accessKey	正确的APP_TOKEN返回accessKey，错误的则提示错误	正确的APP_TOKEN返回accessKey，错误的提示错误	通过
卸载服务模块	将测试类的方法用@RemotableMethod注解标注，在单元测试里调用这个方法	控制台打印被注解的方法所在的类以及相关对象的信息	控制台打印被注解的方法所在的类以及相关对象的信息	通过
	调用SDK获取设备配和网络状态置的API	控制台打印系统配置和网络状态信息	控制台打印系统配置和网络状态信息	通过
	调用SDK方法卸载的API卸载测试类的方法	控制台打印方法卸载后服务器运行的结果	控制台打印方法卸载后服务器运行的结果	通过
	分别对配置了对象代理的方法对象和没有配置对象代理的方法对象进行卸载	设置了对象代理的方法卸载流量消耗较小，未设置对象代理的方法卸载流量消耗较多	设置了对象代理的方法卸载流量消耗较小，未设置对象代理的方法卸载流量消耗较多	通过
权限服务模块	未登录的情况下输入任意后台管理网址	跳转用户登录界面	跳转用户登录界面	通过
	输入管理员账户密码并登录	跳转应用管理页面	跳转应用管理页面	通过
计算服务模块	多台设备同一应用使用计算卸载功能	每台设备的应用正常运行	每台设备的应用正常运行	通过
	多台设备不同应用使用计算卸载功能	每台设备的应用正常运行	每台设备的应用正常运行	通过
	开启网格计算服务，并重复上面两个测试	每台设备的应用正常运行	每台设备的应用正常运行	通过
管理维护模块	进入应用管理页面新建应用	应用注册成功，并返回应用列表	应用注册成功，并返回应用列表	通过
	修改应用主策略	应用主策略修改成功	应用主策略修改成功	通过
	进入卸载记录管理页面，选取不同应用的卸载记录	显示不同应用的卸载记录列表	显示不同应用的卸载记录列表	通过
以上功能性测试结果表明，本文给出的基于Android的计算卸载框架达到了文章给出的需求分析和设计要求的功能点，每个功能模块都能正确的执行，满足用户的功能需求。
2）应用测试
为了看出计算卸载在实际环境下的表现，类似于MAUI与CloneCloud给出的测试方式，本文选取了两个类型不同的开源Android应用程序进行了实机测试。其中一个程序是Android版的中国象棋游戏，对于中国象棋游戏中AI的每一步棋都需要大量的计算才能够得出结果，随着棋局的深入，程序为每一步棋做出的反向测试也会增多，棋局的计算量以指数级的形式进行增加，棋越下到后面，程序的反映越慢。另外一个应用程序是人脸识别的Android应用程序，它的主要功能是对相机获取的照片进行人脸识别，并在原照片上进行人脸的标记。计算量比较平均，但是若是要做计算卸载的话，数据传输量相对于中国象棋的游戏会大很多。
本文将两个不同类型的开源Android应用程序嵌入了移动端SDK，分别在局域网和公网环境下进行了测试。
（1）中国象棋。棋牌类游戏里含有大量的计算单元，对于一些配置比较低的设备，在人机对弈的时候，机器思考的时间可能会比人慢很多，这大多数是由于硬件本身的有限计算资源导致的。我们将一个开源的中国象棋Android应用程序配置了本计算卸载框架，为了进行重复的实验，我们把象棋程序里的随机步数做了修改，使得对于人的每一步机器的对应出棋都是一致的。我们利用谷歌推出的uiautomator自动化测试工具，通过脚本模拟人每一步走的棋子，每一局走30步，则自动结束棋局并进行相关信息的统计。我们分别把原程序与加入计算卸载框架后的程序安装在手机上并在不同网络环境下进行测试，得出如图6-2所示的测试结果。这里我们使用的测试手机为三星GT-N7105，基本配置为2G运行内存，1.6GHz（4核）CPU，运行的操作系统为Android4.1。
图62象棋游戏测试结果
图5-2中，原程序表示没有加入计算卸载框架的象棋游戏，Wifi和3G分别表示加入了计算卸载框架的象棋游戏在Wifi环境和3G环境下执行测试的数据。由图5-2可以很容易看出，没有加入计算卸载框架的象棋游戏，我们走同样的30步棋所需要的时间和消耗的电量都远远大于加入了计算卸载框架的象棋游戏。就此组测试结果而言，原程序平均每步棋需要计算1.3分钟，而加入了计算卸载框架的象棋程序平均每步棋只需要34.8秒，平均速度提升了2.2倍。纵向对比加入了计算卸载后在Wifi环境和3G环境下的耗时对比，整体来说Wifi条件下的执行时间与3G环境下的执行时间相差不大，但是由于移动网络的特殊性，3G环境下的执行速度还是会比Wifi下略慢。对于能耗方面，原程序的能耗也是远远高于加入了计算卸载后的程序，从统计数据来看，加入了计算卸载服务的程序可以比原程序省电60%左右。再纵向对比加入计算卸载后Wifi和3G环境下的耗能数据，3G环境下会比Wifi条件下消耗更多的电量，原因是移动手机在移动网络中进行通信的信号调制比wifi更加复杂，其中主要是通信环节增加了卸载的耗电量。
（2）人脸识别。对于我们前面使用的中国象棋应用程序，它在计算卸载过程中状态的转移并不多，方法涉及到的也只有几个简单的参数。对于本计算卸载框架，我们还设计几种状态转移的策略，用以提高状态转移的效率从而提高计算卸载的效率。我们利用Jon’sJavaImageLibrary（JJIL）库编写了一个人脸识别的Android应用程序。并且也将原应用程序和加入了计算卸载框架的应用程序分别安装在手机里，在不同网络环境下进行了测试，对于执行时间的测试结果如图6-3所示。
图63人脸识别执行时间对比
我们测试的手机依然是三星GT-N7105，对于加入了计算卸载框架的应用程序，我们分别使用了四种状态转移策略在Wifi和3G的网络环境下做测试。测试分为两组，一组只利用程序识别1张图片中的人脸，另外一组利用程序识别10张图片中的人脸，其中测试图片都是同一张图片。从测试结果看来，没有计算卸载框架支持的原程序识别人脸的速度要远慢于加入了计算卸载框架的程序。对于只识别1张图片而不启用对象缓存的情况下，几种传输策略的执行速度相差不多，Lazy策略会稍微比Eager策略和PipeLined策略慢一点点。对于Wifi环境和3G环境下的比较，3G环境依然会比Wifi慢一些。对于识别10张图片的人脸测试，各种策略执行所需要的时间却不是识别1张图片所需要的时间的10倍，它们需要的时间会比识别1张所需要的时间少。纵向比较几种卸载策略的话，Lazy依然还是执行速度最慢的一种策略，因为它每次执行才会向客户端请求需要使用的对象，这样一来回是必消耗更多的时间。对于多图片的识别，PipedLined策略要优于其他两种策略，究其原因是因为PipedLined传输策略相当于传输与计算是并行执行的，所以相对来说速度会比其他两种方式快一些。对于两组测试的能耗对比结果，如图6-4所示。
图64人脸识别执行时间对比
从测试结果看来，计算卸载框架在不启用对象缓存的情况下，Wifi环境下的三种传输策略的能耗相差不多，但是值得注意的是，在3G环境下，Lazy策略的能量消耗明显高于Eager策略和PipedLined策略。造成这种结果的一个重要原因是，在进行移动网络通信时，移动手机依赖的射频通信模块进行3G网络通信的时候，能量的消耗相比较Wifi通信的硬件模块而言，更加消耗设备资源，所以能量也会Wifi环境下消耗的更多。从测试结果还可以看出Lazy策略下，程序执行速度也并不优于其他两种传输策略。那么为什么还要使用这种策略进行状态的转移呢？为了说明这种传输策略存在的意义，我们将此应用程序做了一定的修改，我们将10张图片作为程序的输入，但是我们只对其中一张图片进行识别，这说明在被卸载的方法所指向的方法堆中静态堆中还存在着其他9张图片，也就是说10张图片中，只有一张是计算需要的，而其他9张是多余的。对于这样的情况，我们再次进行了人脸识别的实验。结合前几次实验的数据，我们得到如表6-5所示的测试流量对比表。通过表中数据可以明显看出，若方法所在的堆中涉及到的无关大对象比较多的时候，使用Eager策略和Pipelined策略会大大浪费传输的流量，此时使用Lazy策略的话，可以很好的避免这种浪费。
表65测试流量对比表
应用程序	上行（KB）	下行（KB）
中国象棋	83.5	75.6
人脸识别1张图片（Eager）	196.7	51.5
人脸识别1张图片（Lazy）	196.7	51.4
人脸识别1张图片（Pipelined）	196.3	50.7
人脸识别1张图片（Cache）	1.3	2.7
人脸识别10张图片（Eager）	1486.9	327.8
人脸识别10张图片（Lazy）	1493.6	337.3
表65（续）
应用程序	上行（KB）	下行（KB）
人脸识别10张图片（Pipelined）	1495.6	327.7
人脸识别10张图片（Cache）	1.8	7.8
人脸识别1/10张图片（Eager）	1487.5	323.3
人脸识别1/10张图片（Lazy）	117	28.6
人脸识别1/10张图片（Pipelined）	1494.6	62.1
6.4基于Android的计算卸载框架的运行截图
本小结将展示基于Android的计算卸载框架的使用截图。如图6-5所示为进行中国象棋游戏测试和人脸识别测试的截图。截图均为uiautomator脚本在程序执行过程中截取。

（a）象棋游戏测试截图（b）人脸识别测试截图
图65应用测试截图
如图6-6所示为服务器后台管理系统应用管理模块截图，展示了应用管理模块应用列表的主要信息，用是在这个页面下对应用程序进行各种操作处理的。

图66服务器后台管理系统应用管理模块截图
如图6-7所示为在服务器创建应用操作时的截图。展示的是开发人员创建新应用时的相关应用信息。

图67服务器后台管理系统创建新应用截图
如图6-8所示为服务器后台管理系统历史卸载记录管理模块截图。展示是历史卸载记录列表的相关信息。

图68服务器后台管理系统记录管理模块截图
6.5本章小结
本章完成了对基于Android的计算卸载框架的实现和测试，介绍了系统的开发环境，然后以系统的功能模块为核心进行逐步开发，完成了计算卸载框架的各项功能。在开发的最后阶段对框架进行了功能测试和性能测试，并比对了卸载框架中一些不同策略实现的优缺点，最后展示了计算卸载框架的测试截图和运行效果。



参考文献
[1]	邵林锋,孙孝科.智能手机专利联盟如何走得更远[J].通信企业管理,2014(10):79-81.
[2]	张劳模,马颖,王国栋.移动云计算环境下多平台应用开发框架研究[J].自动化与仪器仪表,2015(8).
[3]	马迎然．移动设备中基于云协助的节能任务调度策略[D]．厦门大学，2014．
[4]	SermpezisP,VigneriL,SpyropoulosT.OffloadingontheEdge:AnalysisandOptimizationofLocalDataStorageandOffloadinginHetNets[J].ComputerScience,2015:1.
[5]	张拥军,史殿习,肖玺等.基于代理的移动云服务访问机制的研究与实现[J].计算机科学,2013,40(5):58-61.
[6]	戴慧B,曲桦,赵季红.利用非精确参数的移动互联网业务感知多目标优化QoS路由算法[J].西安交通大学学报,2014,48(2):86-92.
[7]	ZhangW,WenY,WuDO.Energy-efficientschedulingpolicyforcollaborativeexecutioninmobilecloudcomputing:INFOCOM,2013ProceedingsIEEE,2013[C].
[8]	房秉毅,张云勇,陈清金等.云计算网络虚拟化技术[J].信息通信技术,2011,05(1):50-53.
[9]	王力,赵季红,曲桦等.软件定义承载网中基于负载均衡的虚拟网络资源分配算法[J].电信科学,2015,31(11):32-38.
[10]	郗洋．基于云计算的并行聚类算法研究[D]．南京邮电大学，2011．
[11]	FloresH,SriramaSN.MobileCloudMiddleware[J].JournalofSystemsandSoftware,2014,92:82-94.
[12]	MobileOffloadingFramework:SolutionforOptimizingMobileApplicationsUsingCloudComputing[J].
[13]	涂山山．云计算环境中访问控制的机制和关键技术研究[D]．北京邮电大学，2014．
[14]	CuervoE,BalasubramanianA,ChoDKetal.MAUI:makingsmartphoneslastlongerwithcodeoffload:InternationalConferenceonMobileSystems,Applications,andServices,2010[C].
[15]	GrubertEA,WebberME.EnergyforwaterandwaterforenergyonMauiIsland,Hawaii.[J].EnvironmentalResearchLetters,2015,10(6).
[16]	ChunBG,IhmS,ManiatisPetal.CloneCloud:elasticexecutionbetweenmobiledeviceandcloud:ConferenceonComputerSystems,2011[C].
[17]	KostaS,AucinasA,HuiPetal.ThinkAir:Dynamicresourceallocationandparallelexecutioninthecloudformobilecodeoffloading:INFOCOM,2012ProceedingsIEEE,2012[C].
[18]	宋远任．移动云计算平台上的效率关键技术研究及系统实施[D]．哈尔滨工业大学，2014．
[19]	杨存,赵季红,赵庶源等.基于多终端协同的终端与网络协同选择算法研究[J].计算机技术与发展,2015(1):52-56.
[20]	ChoiI.AStudyontheRuleSeparationBasedonAOPforEfficientServiceSystem[J].PacificScienceReview,2015,13.
[21]	EliasE,SantosJ,BittencourtIIetal.ASemi-automaticsystemtoevaluatetheperformanceandscalabilityofontologypersistentAPIs[J].ScienceofComputerProgramming,2016.
[22]	ChenL,QuH,ZhaoJetal.EfficientandrobustdeeplearningwithCorrentropy-inducedlossfunction[J].NeuralComputingandApplications,2016,27(4):1019-1031.
[23]	陈雯柏．人工神经网络原理与实践[M]．西安电子科技大学出版社，2016：
[24]	田洁,赵季红,曲桦.泛在网络环境下移动性预测方法的挑战及关键思想[J].电信科学,2013,29(11):66-71.
[25]	ChibaS.Load-TimeStructuralReflectioninJava[J].2000,1850:313-336.
[26]	王循．JavaWeb快速开发框架中部分关键技术初步研究[D]．吉林大学，2015．
[27]	RiesCB.BOINC[M].SpringerBerlinHeidelberg,2012.
[28]	EllouzeA,GagnaireM,HaddadA.AMobileApplicationOffloadingAlgorithmforMobileCloudComputing:IEEEInternationalConferenceonMobileCloudComputing,Services,andEngineering,2015[C].
[29]	HuaQU,WentaoMA,ZhaoJetal.PredictionMethodforNetworkTrafficBasedonMaximumCorrentropyCriterion[J].中国通信(英文版),2013,10(1):134-145.
[30]	吕曦,王化文.WebService的架构与协议[J].计算机应用,2002,22(12):62-65.
[31]	曲桦,赵季红,郭爽乐等.基于最小代价的虚拟网络重配置方法[J].北京邮电大学学报,2014,37(5):114-118.
[32]	MilesR.AspectJcookbook[J].OreillyMedia,2016.
[33]	HollowayRW,Miller-RobbieL,PatelMetal.Life-cycleassessmentoftwopotablewaterreusetechnologies:MF/RO/UV-AOPtreatmentandhybridosmoticmembranebioreactors[J].JournalofMembraneScience,2016,507:165-178.
[34]	GiurgiuI,RivaO,JuricDetal.CallingtheCloud:EnablingMobilePhonesasInterfacestoCloudApplications:MIDDLEWARE2009,Acm/ifip/usenix,InternationalMIDDLEWAREConference,Urbana,Il,Usa,November30-December4,2009.Proceedings,2009[C].
[35]	戴亮,方晓勤,李丽.一种新的基于序列化的JavaRMI方法[J].计算机工程,2006,32(22):99-101.

